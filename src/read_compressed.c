#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "ds.h"

#include "read_compressed.h"

/*A function for getting the header for an entry in the compressed links file.
  Returns NULL if EOF is found before a newline.*/
char *get_header(FILE *f){
    int c = 0;
    char *header = malloc(10000*sizeof(*header));
    int header_length = 10000;
    int i = 0;
    while(c != EOF && c != '\n'){
        c = getc(f);
        if(c != EOF){
            header[i] = (char)c;
            i++;
            if(i == header_length-1){
                header_length *= 2;
                header = realloc(header, header_length*sizeof(*header));
            }
        }
        else
            return NULL;
    }
    header[i] = '\0';
    header = realloc(header, (i+1)*sizeof(*header));
    return header;
}

/*Reads one link from a file with the links to the coarse database and converts
  its data to a struct cbp_link_to_coarse*/
struct cbp_link_to_coarse *read_link(FILE *f){
    int i;
    unsigned int c = 0;
    struct cbp_link_to_coarse *link = malloc(sizeof(*link));
    uint64_t coarse_seq_id = (uint64_t)0;
    uint16_t coarse_start = (uint16_t)0;
    uint16_t coarse_end = (uint16_t)0;
    uint16_t script_length = (uint16_t)0;
    int chars_to_read;
    char *half_bytes;
    char *diff;
    unsigned char indices[6];

    for(i = 0; i < 8; i++){
        c = getc(f);
        if(feof(f)){
            free(link);
            fprintf(stderr, "?\n");
            return NULL;
        }
        coarse_seq_id <<= 8;
        coarse_seq_id |= (uint64_t)c;
    }

    for(i = 0; i < 6; i++){
        c = getc(f);
        if(feof(f)){
            free(link);
            fprintf(stderr, "??\n");
            return NULL;
        }
        indices[i] = (char)c;
    }
    coarse_start |= (uint16_t)indices[0];
    coarse_start <<= 8;
    coarse_start |= (uint16_t)indices[1];
    coarse_end |= (uint16_t)indices[2];
    coarse_end <<= 8;
    coarse_end |= (uint16_t)indices[3];
    script_length |= (uint16_t)indices[4];
    script_length <<= 8;
    script_length |= (uint16_t)indices[5];
    chars_to_read = script_length / 2;
    if(script_length % 2 == 1)
        chars_to_read++;
    half_bytes = malloc(chars_to_read*sizeof(*half_bytes));
    for(i = 0; i < chars_to_read; i++){
        c = getc(f);
        if(feof(f)){
            free(link);
            return NULL;
        }
        half_bytes[i] = (char)c;
    }
    diff = half_bytes_to_ASCII(half_bytes, script_length);
    link->diff = diff;
    link->coarse_seq_id = coarse_seq_id;
    link->coarse_start = coarse_start;
    link->coarse_end = coarse_end;
    return link;
}

/*Takes the compressed.cbp generated by cablastp-compress and parses it to get
  an array of compressed sequences.*/
struct cbp_compressed_seq **read_compressed(FILE *f){
    int length = 0;
    struct cbp_compressed_seq **compressed_seqs =
        malloc(1000*sizeof(*compressed_seqs));
    while(true){
        char *header = get_header(f);
        if(header == NULL)
            break;
        struct cbp_link_to_coarse *links = NULL;
        while(true){
            char c = 1;
            struct cbp_link_to_coarse *current_link = read_link(f);
            if(current_link == NULL)
               break;
            current_link -> next = links;
            links = current_link;
            c = getc(f);
            if(c == '\n')
                break;
        }
        compressed_seqs[length] = malloc(sizeof(*(compressed_seqs[length])));
        (compressed_seqs[length])->name = header;
        (compressed_seqs[length]->links) = links;
        length++;
    }

    compressed_seqs=realloc(compressed_seqs, (length+1)*sizeof(*compressed_seqs));
    compressed_seqs[length] = NULL;
    return compressed_seqs;
}

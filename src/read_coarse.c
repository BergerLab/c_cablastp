#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "ds.h"

#include "read_coarse.h"
#include "seq.h"

/*A function for getting the header for an entry in the coarse links file.
  Returns NULL if EOF is found before a newline.*/
char *get_coarse_header(FILE *f){
    int c = 0;
    char *header = malloc(30*sizeof(*header));
    int header_length = 30;
    int i = 0;
    while (c != EOF && c != '\n'){
        c = getc(f);
        if (c != EOF) {
            header[i] = (char)c;
            i++;
            if (i == header_length-1) {
                header_length *= 2;
                header = realloc(header, header_length*sizeof(*header));
            }
        }
        else
            return NULL;
    }
    header[i] = '\0';
    header = realloc(header, (i+1)*sizeof(*header));
    return header;
}

/*Reads one link from a file with the links to the compressed database and
  converts its data to a struct cbp_link_to_compressed*/
struct cbp_link_to_compressed *read_coarse_link(FILE *f){    
    int i;
    unsigned int c = 0;
    struct cbp_link_to_compressed *link = malloc(sizeof(*link));
    uint64_t org_seq_id = (uint64_t)0;
    uint16_t coarse_start = (uint64_t)0;
    uint16_t coarse_end = (uint64_t)0;
    bool dir;
    unsigned char indices[5];

    for (i = 0; i < 8; i++){
        c = getc(f);
        if (feof(f)) {
            free(link);
            return NULL;
        }
        org_seq_id <<= 8;
        org_seq_id |= (uint64_t)c;
    }
    for (i = 0; i < 5; i++){
        c = getc(f);
        if (feof(f)) {
            free(link);
            return NULL;
        }
        indices[i] = (char)c;
    }

    coarse_start |= (uint16_t)indices[0];
    coarse_start <<= 8;
    coarse_start |= (uint16_t)indices[1];
    coarse_end |= (uint16_t)indices[2];
    coarse_end <<= 8;
    coarse_end |= (uint16_t)indices[3];
    dir = (char)indices[4] == '0';

    link->org_seq_id = org_seq_id;
    link->coarse_start = coarse_start;
    link->coarse_end = coarse_end;
    link->dir = dir;
    link->next = NULL;

    return link;
}

/*Takes in a coarse database, the coarse.links file generated by
  cablastp-compress, and a FASTA sequence generator for the coarse.fasta file
  generated by cablastp-compress and populates the coarse database with a
  coarse sequence for each FASTA sequence and a link_to_compressed in each
  sequence corresponding to each link in the links file.*/
void read_coarse(struct cbp_coarse *coarse_db, FILE *links_file,
                 struct fasta_seq_gen *fsg){
    /*Read each sequence*/
    while (true) {
        struct cbp_link_to_compressed *links = NULL;
        char *header = get_coarse_header(links_file);
        struct fasta_seq *coarse_fasta_seq = fasta_generator_next(fsg);
        struct cbp_coarse_seq *current_sequence = NULL;
        
        if (header == NULL)
            break;

        current_sequence = cbp_coarse_add(coarse_db, coarse_fasta_seq->seq, 0,
                                          strlen(coarse_fasta_seq->name));

        /*Read each link in the sequence*/
        while (true) {
            char c = 1;
            struct cbp_link_to_compressed *current_link =
                                          read_coarse_link(links_file);
            if (current_link == NULL)
                break;
            current_link->next = links;
            if (current_link->next == NULL)
                links = current_link;
            else {
                while (current_link->next->next != NULL)
                    current_link->next = current_link->next->next;
                current_link->next->next = current_link;
                current_link->next = NULL;
            }

            cbp_coarse_seq_addlink(current_sequence, current_link);

            c = getc(links_file);
            if (c == '#')
                break;
        }
    }
}

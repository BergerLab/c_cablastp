#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "ds.h"

#include "edit_scripts.h"
#include "read_compressed.h"
#include "read_coarse.h"
#include "seq.h"
#include "util.h"

int get_min(int a, int b){return a<b?a:b;}
int get_max(int a, int b){return a>b?a:b;}

/*A function for getting the header for an entry in the coarse links file.
  Returns NULL if EOF is found before a newline.*/
char *get_coarse_header(FILE *f){
    int c = 0;
    char *header = malloc(30*sizeof(*header));
    int header_length = 30;
    int i = 0;
    while (c != EOF && c != '\n') {
        c = getc(f);
        if (c != EOF) {
            header[i] = (char)c;
            i++;
            if (i == header_length - 1) {
                header_length *= 2;
                header = realloc(header, header_length*sizeof(*header));
            }
        }
        else
            return NULL;
    }
    header[i] = '\0';
    header = realloc(header, (i+1)*sizeof(*header));
    return header;
}

/*Reads one link from a file with the links to the compressed database and
  converts its data to a struct cbp_link_to_compressed*/
struct cbp_link_to_compressed *read_coarse_link(FILE *f){
    struct cbp_link_to_compressed *link = malloc(sizeof(*link));
    link->org_seq_id = (uint64_t)read_int_from_file(8, f);
    if (feof(f)) {
        free(link);
        return NULL;
    }

    link->coarse_start = (uint16_t)read_int_from_file(2, f);
    if (feof(f)) {
        free(link);
        return NULL;
    }

    link->coarse_end = (uint16_t)read_int_from_file(2, f);
    if (feof(f)) {
        free(link);
        return NULL;
    }

    link->original_start = (uint64_t)read_int_from_file(8, f);
    if (feof(f)) {
        free(link);
        return NULL;
    }

    link->original_end = (uint64_t)read_int_from_file(8, f);
    if (feof(f)) {
        free(link);
        return NULL;
    }

    link->dir = getc(f) == '0';
    link->next = NULL;
    return link;
}

/*Takes in a pointer to the coarse.links file generated by cablastp-compress and
 *returns a vector containing all of the links in the coarse database entry for
 *the sequence the file pointer currently points to.  For this function to work
 *properly the file pointer must be pointing to the start of the header of a
 *sequence entry in the links file.
 */
struct DSVector *get_coarse_sequence_links(FILE *f){
    struct DSVector *links = ds_vector_create();
    char *h = get_coarse_header(f);
    if (h == NULL) {
        ds_vector_free(links);
        return NULL;
    }
    free(h);

    while (true) {
        char c = 1;
        struct cbp_link_to_compressed *current_link = read_coarse_link(f);
        if (current_link == NULL)
            break;
        ds_vector_append(links, (void *)current_link);
        c = getc(f);
        if (c == '#')
            break;
    }
    return links;
}

/*A wrapper function for get_coarse_sequence_links that handles fseek calls;
 *seeks to the index in the coarse.links file for the sequence at index id
 *and then calls get_coarse_sequence_links.  If fseek is successful, then
 *return the coarse sequence links for the coarse sequence at index id.
 *Otherwise, return NULL.
 */
struct DSVector *get_coarse_sequence_links_at(FILE *links, FILE *index,
                                                           int32_t id){
    int64_t offset = cbp_coarse_find_offset(index, id);
    if (offset < 0)
        return NULL;
    bool fseek_success = fseek(links, offset, SEEK_SET) == 0;
    if (!fseek_success) { 
        fprintf(stderr, "Error in seeking to offset %lu\n", offset);
        return NULL;
    }
    return get_coarse_sequence_links(links);
}

struct DSVector *
cbp_coarse_expand(struct cbp_coarse *coarsedb, struct cbp_compressed *comdb,
                  int32_t id, int32_t start, int32_t end,
                  int32_t hit_pad_length){
fprintf(stderr, "==========================================cbp_coarse_expand %d   %d-%d\n===================================================", id, start, end);
    FILE *links = coarsedb->file_links;
    FILE *coarse_links_index = coarsedb->file_links_index;
    FILE *fasta = coarsedb->file_fasta;
    FILE *compressed = comdb->file_compressed;

    struct DSVector *oseqs = ds_vector_create();
    struct DSVector *coarse_seq_links =
        get_coarse_sequence_links_at(links, coarse_links_index, id);
    struct fasta_seq *residues = cbp_coarse_read_fasta_seq(coarsedb, id);
    int fasta_length = strlen(residues->seq);
    int64_t *seq_lengths = cbp_compressed_get_lengths(comdb);

    int i = 0;
    for (i = 0; i < coarse_seq_links->size; i++) {
        struct cbp_link_to_compressed *link =
            (struct cbp_link_to_compressed *)ds_vector_get(coarse_seq_links, i);
        if (link->coarse_start <= end && link->coarse_end >= start) {
            bool dir = link->dir;

            uint64_t original_start =
                get_max(0, (dir ? get_min(start + (link->original_start -
                                                   link->coarse_start),
                                          start + (link->original_end -
                                                   link->coarse_end)) :
                        get_min(link->original_start + link->coarse_end-end,
                                link->original_start - (end-link->coarse_end)))
                             - hit_pad_length);

            uint64_t original_end =
                get_min((dir ? get_max(end + (link->original_start -
                                              link->coarse_start),
                                       end + (link->original_end -
                                              link->coarse_end)) :
                     get_max(link->original_end - (start - link->coarse_start),
                             link->coarse_start + link->coarse_end - start))
                 + hit_pad_length, seq_lengths[link->org_seq_id]);

            fprintf(stderr, "%lu-%lu\n", original_start, original_end);

            struct cbp_compressed_seq *seq =
                       cbp_compressed_read_seq_at(comdb,link->org_seq_id);
            struct cbp_link_to_coarse *links_to_decompress = seq->links;
            for (; links_to_decompress;
                   links_to_decompress = links_to_decompress->next)
                if (links_to_decompress->original_end >= original_start &&
                    links_to_decompress->original_start <= original_end)
                    break;
            struct cbp_link_to_coarse *current = links_to_decompress;
            while(current && current->original_start <= original_end &&
                             current->original_end >= original_start){
                char *decompressed = read_edit_script(current->diff,
                                                      residues->seq,
                                                      fasta_length);
                int start_index = original_start - link->original_start;
                int end_index = original_end - link->original_start;
                char *section = str_slice(decompressed, start_index, end_index);
                section[end_index-start_index] = '\0';
                fprintf(stderr, "%s\n", section);

                current = current -> next;
            }
            cbp_compressed_seq_free(seq);
        }
    }

    return NULL;
}

/*Takes in an index file from a coarse database and the ID number of the
  sequence in the corresponding database file that the user wants to seek to
  and returns the byte offset of the sequence in its database file.*/
int64_t cbp_coarse_find_offset(FILE *index_file, int id){
    int i;
    int try_off = id * 8;
    bool fseek_success = fseek(index_file, try_off, SEEK_SET) == 0;
    int64_t mask = make_mask(8);
    int64_t offset = (int64_t)(-1);
    if (!fseek_success) {
        fprintf(stderr, "Error in seeking to offset %d\n", try_off);
        return (int64_t)(-1);
    }
    for (i = 0; i < 8; i++) {
        int64_t current_byte=((int64_t)(getc(index_file))&mask);
        offset <<= 8;
        offset |= current_byte;
    }
    return offset;
}

/*Takes in as arguments a coarse database and the ID number of the sequence in
 *the coarse FASTA file to read in and gets a struct fasta_seq for that
 *sequence.
 */
struct fasta_seq *cbp_coarse_read_fasta_seq(struct cbp_coarse *coarsedb, int id){
    int64_t offset = cbp_coarse_find_offset(coarsedb->file_fasta_index, id);
    if (offset < 0)
        return NULL;
    bool fseek_success = fseek(coarsedb->file_fasta, offset, SEEK_SET) == 0;
    if (!fseek_success) {
        fprintf(stderr, "Error in seeking to offset %d\n", offset);
        return NULL;
    }
    return fasta_read_next(coarsedb->file_fasta, "");
}

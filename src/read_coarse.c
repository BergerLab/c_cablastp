#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "ds.h"

#include "read_coarse.h"
#include "seq.h"

/*A function for getting the header for an entry in the coarse links file.
  Returns NULL if EOF is found before a newline.*/
char *get_coarse_header(FILE *f){
    int c = 0;
    char *header = malloc(30*sizeof(*header));
    int header_length = 30;
    int i = 0;
    while (c != EOF && c != '\n'){
        c = getc(f);
        if (c != EOF) {
            header[i] = (char)c;
            i++;
            if (i == header_length-1) {
                header_length *= 2;
                header = realloc(header, header_length*sizeof(*header));
            }
        }
        else
            return NULL;
    }
    header[i] = '\0';
    header = realloc(header, (i+1)*sizeof(*header));
    return header;
}

/*Reads one link from a file with the links to the compressed database and
  converts its data to a struct cbp_link_to_compressed*/
struct cbp_link_to_compressed *read_coarse_link(FILE *f){    
    int i;
    unsigned int c = 0;
    struct cbp_link_to_compressed *link = malloc(sizeof(*link));
    uint64_t org_seq_id = (uint64_t)0;
    uint16_t coarse_start = (uint64_t)0;
    uint16_t coarse_end = (uint64_t)0;
    bool dir;
    unsigned char indices[5];

    for (i = 0; i < 8; i++){
        c = getc(f);
        if (feof(f)) {
            free(link);
            return NULL;
        }
        org_seq_id <<= 8;
        org_seq_id |= (uint64_t)c;
    }
    for (i = 0; i < 5; i++){
        c = getc(f);
        if (feof(f)) {
            free(link);
            return NULL;
        }
        indices[i] = (char)c;
    }

    coarse_start |= (uint16_t)indices[0];
    coarse_start <<= 8;
    coarse_start |= (uint16_t)indices[1];
    coarse_end |= (uint16_t)indices[2];
    coarse_end <<= 8;
    coarse_end |= (uint16_t)indices[3];
    dir = (char)indices[4] == '0';

    link->org_seq_id = org_seq_id;
    link->coarse_start = coarse_start;
    link->coarse_end = coarse_end;
    link->dir = dir;
    link->next = NULL;

    return link;
}

/*Takes the coarse.links generated by cablastp-compress and parses it to get
  an array of coarse sequences.*/
struct cbp_coarse_seq **read_coarse(FILE *links_file, struct fasta_seq_gen *fsg){
    int length = 0;
    struct cbp_coarse_seq **coarse_seqs =
        malloc(1000*sizeof(*coarse_seqs));
    /*Read each sequence*/
    while (true) {
        struct cbp_link_to_compressed *links = NULL;
        char *header = get_coarse_header(links_file);
        struct fasta_seq *coarse_fasta_seq = fasta_generator_next(fsg);
        struct cbp_seq *coarse_seq = malloc(sizeof(*coarse_seq));
        
        if (header == NULL)
            break;
        coarse_seqs[length] = malloc(sizeof(*(coarse_seqs[length])));
        (coarse_seqs[length])->id = atoi(header+2);

        coarse_seq->id = coarse_seqs[length]->id;
        coarse_seq->name = coarse_fasta_seq->name;
        coarse_seq->residues = coarse_fasta_seq->seq;
        coarse_seq->length = strlen(coarse_fasta_seq->name);

        coarse_seqs[length]->seq = coarse_seq;
        /*Read each link in the sequence*/
        while (true) {
            char c = 1;
            struct cbp_link_to_compressed *current_link =
                                          read_coarse_link(links_file);
            if (current_link == NULL)
                break;
            current_link->next = links;
            if (current_link->next == NULL)
                links = current_link;
            else {
                while (current_link->next->next != NULL)
                    current_link->next = current_link->next->next;
                current_link->next->next = current_link;
                current_link->next = NULL;
            }
            c = getc(links_file);
            if (c == '#')
                break;
        }
        (coarse_seqs[length]->links) = links;
        length++;
    }
    coarse_seqs = realloc(coarse_seqs,
                              (length+1)*sizeof(*coarse_seqs));
    coarse_seqs[length] = NULL;
    return coarse_seqs;
}
